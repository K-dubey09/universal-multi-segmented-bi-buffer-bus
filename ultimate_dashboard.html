<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UMSBB v4.0 Ultimate Performance Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-item {
            text-align: center;
        }
        
        .status-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ade80;
        }
        
        .status-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
        }
        
        .metric-title {
            font-size: 1.1em;
            margin-bottom: 15px;
            text-align: center;
            opacity: 0.9;
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .metric-unit {
            text-align: center;
            opacity: 0.7;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: 400px;
        }
        
        .chart-title {
            font-size: 1.3em;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .chart {
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-line {
            stroke: #4ade80;
            stroke-width: 2;
            fill: none;
        }
        
        .chart-area {
            fill: url(#gradient);
            opacity: 0.3;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .controls h3 {
            margin-bottom: 15px;
            text-align: center;
        }
        
        .control-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(0);
        }
        
        .alert {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .success {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid #22c55e;
        }
        
        .performance-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            margin: 5px;
        }
        
        .badge-exceptional { background: #10b981; }
        .badge-excellent { background: #3b82f6; }
        .badge-good { background: #8b5cf6; }
        .badge-baseline { background: #f59e0b; }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            opacity: 0.7;
            font-size: 0.9em;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .loading {
            animation: pulse 2s infinite;
        }
        
        @media (max-width: 768px) {
            .status-bar {
                flex-direction: column;
                gap: 15px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: center;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Header -->
        <div class="header">
            <h1>🚀 UMSBB v4.0 Ultimate Performance Dashboard</h1>
            <div class="subtitle">Real-time GPU-Accelerated Multi-GB/s System Monitoring</div>
        </div>
        
        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-value" id="status-test">Initializing...</div>
                <div class="status-label">Test Status</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="status-time">00:00</div>
                <div class="status-label">Elapsed Time</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="status-gpu">Unknown</div>
                <div class="status-label">GPU Status</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="status-threads">0</div>
                <div class="status-label">Active Threads</div>
            </div>
        </div>
        
        <!-- Real-time Metrics Grid -->
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-title">📊 Current Throughput</div>
                <div class="metric-value" id="metric-throughput">0.0</div>
                <div class="metric-unit">Mbps</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">⚡ Message Rate</div>
                <div class="metric-value" id="metric-message-rate">0</div>
                <div class="metric-unit">msg/sec</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">🎯 Peak Throughput</div>
                <div class="metric-value" id="metric-peak-throughput">0.0</div>
                <div class="metric-unit">Mbps</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">🚀 GPU Utilization</div>
                <div class="metric-value" id="metric-gpu-util">0.0</div>
                <div class="metric-unit">%</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">📤 Messages Sent</div>
                <div class="metric-value" id="metric-sent">0</div>
                <div class="metric-unit">total</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-title">📥 Messages Received</div>
                <div class="metric-value" id="metric-received">0</div>
                <div class="metric-unit">total</div>
            </div>
        </div>
        
        <!-- Throughput Chart -->
        <div class="chart-container">
            <div class="chart-title">📈 Real-time Throughput (Mbps)</div>
            <div class="chart">
                <svg width="100%" height="100%" id="throughput-chart">
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#4ade80;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#4ade80;stop-opacity:0" />
                        </linearGradient>
                    </defs>
                </svg>
            </div>
        </div>
        
        <!-- Message Rate Chart -->
        <div class="chart-container">
            <div class="chart-title">⚡ Message Rate (messages/second)</div>
            <div class="chart">
                <svg width="100%" height="100%" id="message-rate-chart">
                    <defs>
                        <linearGradient id="gradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:0" />
                        </linearGradient>
                    </defs>
                </svg>
            </div>
        </div>
        
        <!-- Performance Classification -->
        <div class="controls">
            <h3>🏆 Performance Classification</h3>
            <div id="performance-badges"></div>
        </div>
        
        <!-- Test Controls -->
        <div class="controls">
            <h3>🎮 Test Controls</h3>
            <div class="control-group">
                <button class="control-btn" onclick="startTest()">▶️ Start Test</button>
                <button class="control-btn" onclick="stopTest()">⏹️ Stop Test</button>
                <button class="control-btn" onclick="resetStats()">🔄 Reset Stats</button>
                <button class="control-btn" onclick="exportData()">💾 Export Data</button>
                <button class="control-btn" onclick="toggleGPU()">🚀 Toggle GPU</button>
            </div>
        </div>
        
        <!-- Alerts -->
        <div id="alerts"></div>
        
        <!-- Footer -->
        <div class="footer">
            <p>UMSBB v4.0 - Universal Multi-Segmented Bi-Buffer Bus | Real-time Performance Dashboard</p>
            <p>Last updated: <span id="last-updated">Never</span></p>
        </div>
    </div>

    <script>
        // Dashboard state
        let dashboardState = {
            isConnected: false,
            testRunning: false,
            startTime: null,
            throughputData: [],
            messageRateData: [],
            maxDataPoints: 60,
            updateInterval: null,
            stats: {
                messagesSent: 0,
                messagesReceived: 0,
                bytesSent: 0,
                bytesReceived: 0,
                peakThroughput: 0,
                peakMessageRate: 0,
                gpuUtilization: 0
            }
        };
        
        // Initialize dashboard
        function initDashboard() {
            console.log('🚀 Initializing UMSBB v4.0 Dashboard...');
            connectToBackend();
            updateStatus();
            startUpdateLoop();
        }
        
        // Connect to backend WebSocket
        function connectToBackend() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('✅ Connected to UMSBB backend');
                    dashboardState.isConnected = true;
                    showAlert('Connected to UMSBB v4.0 system', 'success');
                };
                
                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        updateDashboardData(data);
                    } catch (e) {
                        console.error('Failed to parse WebSocket data:', e);
                    }
                };
                
                ws.onclose = function() {
                    console.log('⚠️ Disconnected from UMSBB backend');
                    dashboardState.isConnected = false;
                    showAlert('Disconnected from backend. Retrying...', 'error');
                    setTimeout(connectToBackend, 5000);
                };
                
                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    showAlert('Connection error occurred', 'error');
                };
                
            } catch (e) {
                console.error('Failed to create WebSocket connection:', e);
                // Fallback to HTTP polling
                startHttpPolling();
            }
        }
        
        // Fallback HTTP polling
        function startHttpPolling() {
            setInterval(async () => {
                try {
                    const response = await fetch('/api/stats');
                    if (response.ok) {
                        const data = await response.json();
                        updateDashboardData(data);
                        if (!dashboardState.isConnected) {
                            dashboardState.isConnected = true;
                            showAlert('Connected via HTTP polling', 'success');
                        }
                    }
                } catch (e) {
                    if (dashboardState.isConnected) {
                        dashboardState.isConnected = false;
                        showAlert('Connection lost', 'error');
                    }
                }
            }, 1000);
        }
        
        // Update dashboard with new data
        function updateDashboardData(data) {
            // Update stats
            dashboardState.stats = { ...dashboardState.stats, ...data };
            
            // Calculate current rates
            const currentThroughput = calculateThroughput(data.bytesSent);
            const currentMessageRate = calculateMessageRate(data.messagesSent);
            
            // Update peak values
            if (currentThroughput > dashboardState.stats.peakThroughput) {
                dashboardState.stats.peakThroughput = currentThroughput;
            }
            if (currentMessageRate > dashboardState.stats.peakMessageRate) {
                dashboardState.stats.peakMessageRate = currentMessageRate;
            }
            
            // Add to chart data
            const now = Date.now();
            dashboardState.throughputData.push({ time: now, value: currentThroughput });
            dashboardState.messageRateData.push({ time: now, value: currentMessageRate });
            
            // Limit data points
            if (dashboardState.throughputData.length > dashboardState.maxDataPoints) {
                dashboardState.throughputData.shift();
            }
            if (dashboardState.messageRateData.length > dashboardState.maxDataPoints) {
                dashboardState.messageRateData.shift();
            }
            
            // Update UI
            updateMetrics(currentThroughput, currentMessageRate);
            updateCharts();
            updatePerformanceBadges();
            updateLastUpdated();
        }
        
        // Calculate throughput in Mbps
        function calculateThroughput(totalBytes) {
            // This is a simplified calculation - real implementation would track rate
            return (totalBytes * 8) / (1024 * 1024) / getElapsedTime();
        }
        
        // Calculate message rate
        function calculateMessageRate(totalMessages) {
            return totalMessages / getElapsedTime();
        }
        
        // Get elapsed time in seconds
        function getElapsedTime() {
            if (!dashboardState.startTime) return 1;
            return Math.max(1, (Date.now() - dashboardState.startTime) / 1000);
        }
        
        // Update metric displays
        function updateMetrics(currentThroughput, currentMessageRate) {
            document.getElementById('metric-throughput').textContent = currentThroughput.toFixed(1);
            document.getElementById('metric-message-rate').textContent = Math.round(currentMessageRate).toLocaleString();
            document.getElementById('metric-peak-throughput').textContent = dashboardState.stats.peakThroughput.toFixed(1);
            document.getElementById('metric-gpu-util').textContent = (dashboardState.stats.gpuUtilization || 0).toFixed(1);
            document.getElementById('metric-sent').textContent = (dashboardState.stats.messagesSent || 0).toLocaleString();
            document.getElementById('metric-received').textContent = (dashboardState.stats.messagesReceived || 0).toLocaleString();
        }
        
        // Update charts
        function updateCharts() {
            updateChart('throughput-chart', dashboardState.throughputData, '#4ade80', 'gradient');
            updateChart('message-rate-chart', dashboardState.messageRateData, '#3b82f6', 'gradient2');
        }
        
        // Update a specific chart
        function updateChart(chartId, data, color, gradientId) {
            const chart = document.getElementById(chartId);
            const rect = chart.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            if (data.length < 2) return;
            
            // Calculate scales
            const maxValue = Math.max(...data.map(d => d.value));
            const xScale = width / (dashboardState.maxDataPoints - 1);
            const yScale = height / (maxValue * 1.1);
            
            // Build path
            let pathData = '';
            let areaData = '';
            
            data.forEach((point, index) => {
                const x = index * xScale;
                const y = height - (point.value * yScale);
                
                if (index === 0) {
                    pathData += `M ${x} ${y}`;
                    areaData += `M ${x} ${height} L ${x} ${y}`;
                } else {
                    pathData += ` L ${x} ${y}`;
                    areaData += ` L ${x} ${y}`;
                }
            });
            
            areaData += ` L ${(data.length - 1) * xScale} ${height} Z`;
            
            // Update SVG
            chart.innerHTML = `
                <defs>
                    <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:${color};stop-opacity:0.6" />
                        <stop offset="100%" style="stop-color:${color};stop-opacity:0" />
                    </linearGradient>
                </defs>
                <path d="${areaData}" fill="url(#${gradientId})"></path>
                <path d="${pathData}" stroke="${color}" stroke-width="2" fill="none"></path>
            `;
        }
        
        // Update performance badges
        function updatePerformanceBadges() {
            const container = document.getElementById('performance-badges');
            const throughputGbps = dashboardState.stats.peakThroughput / 1024;
            const messageRate = dashboardState.stats.peakMessageRate;
            
            let badges = '';
            
            // Throughput classification
            if (throughputGbps >= 10) {
                badges += '<span class="performance-badge badge-exceptional">⭐⭐⭐ EXCEPTIONAL: ' + throughputGbps.toFixed(2) + ' GB/s</span>';
            } else if (throughputGbps >= 5) {
                badges += '<span class="performance-badge badge-excellent">⭐⭐ EXCELLENT: ' + throughputGbps.toFixed(2) + ' GB/s</span>';
            } else if (throughputGbps >= 1) {
                badges += '<span class="performance-badge badge-good">⭐ GOOD: ' + throughputGbps.toFixed(2) + ' GB/s</span>';
            } else {
                badges += '<span class="performance-badge badge-baseline">💡 BASELINE: ' + throughputGbps.toFixed(2) + ' GB/s</span>';
            }
            
            // Message rate classification
            if (messageRate >= 1000000000) {
                badges += '<span class="performance-badge badge-exceptional">🚀 BILLION+ Messages/Sec</span>';
            } else if (messageRate >= 100000000) {
                badges += '<span class="performance-badge badge-excellent">🔥 HUNDRED MILLION+ Messages/Sec</span>';
            } else if (messageRate >= 10000000) {
                badges += '<span class="performance-badge badge-good">⚡ TEN MILLION+ Messages/Sec</span>';
            }
            
            container.innerHTML = badges || '<span class="performance-badge badge-baseline">📊 Building Performance Data...</span>';
        }
        
        // Update status displays
        function updateStatus() {
            document.getElementById('status-test').textContent = dashboardState.testRunning ? 'Running' : 'Idle';
            document.getElementById('status-time').textContent = formatElapsedTime();
            document.getElementById('status-gpu').textContent = dashboardState.isConnected ? 'Active' : 'Unknown';
            document.getElementById('status-threads').textContent = '8'; // Could be dynamic
        }
        
        // Format elapsed time
        function formatElapsedTime() {
            if (!dashboardState.startTime) return '00:00';
            const elapsed = Math.floor((Date.now() - dashboardState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Update last updated timestamp
        function updateLastUpdated() {
            document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
        }
        
        // Show alert message
        function showAlert(message, type = 'info') {
            const alertsContainer = document.getElementById('alerts');
            const alertClass = type === 'success' ? 'alert success' : 'alert';
            
            const alertHtml = `
                <div class="${alertClass}">
                    ${message}
                </div>
            `;
            
            alertsContainer.innerHTML = alertHtml;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                alertsContainer.innerHTML = '';
            }, 5000);
        }
        
        // Start update loop
        function startUpdateLoop() {
            dashboardState.updateInterval = setInterval(() => {
                updateStatus();
            }, 1000);
        }
        
        // Control functions
        function startTest() {
            if (!dashboardState.testRunning) {
                dashboardState.testRunning = true;
                dashboardState.startTime = Date.now();
                showAlert('Performance test started', 'success');
                
                // Send start command to backend
                fetch('/api/start', { method: 'POST' })
                    .catch(e => console.error('Failed to start test:', e));
            }
        }
        
        function stopTest() {
            if (dashboardState.testRunning) {
                dashboardState.testRunning = false;
                showAlert('Performance test stopped', 'info');
                
                // Send stop command to backend
                fetch('/api/stop', { method: 'POST' })
                    .catch(e => console.error('Failed to stop test:', e));
            }
        }
        
        function resetStats() {
            dashboardState.stats = {
                messagesSent: 0,
                messagesReceived: 0,
                bytesSent: 0,
                bytesReceived: 0,
                peakThroughput: 0,
                peakMessageRate: 0,
                gpuUtilization: 0
            };
            dashboardState.throughputData = [];
            dashboardState.messageRateData = [];
            dashboardState.startTime = null;
            
            updateMetrics(0, 0);
            updateCharts();
            updatePerformanceBadges();
            showAlert('Statistics reset', 'info');
        }
        
        function exportData() {
            const data = {
                timestamp: new Date().toISOString(),
                stats: dashboardState.stats,
                throughputData: dashboardState.throughputData,
                messageRateData: dashboardState.messageRateData
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `umsbb_performance_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showAlert('Performance data exported', 'success');
        }
        
        function toggleGPU() {
            fetch('/api/toggle-gpu', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    showAlert(`GPU acceleration ${data.enabled ? 'enabled' : 'disabled'}`, 'success');
                })
                .catch(e => {
                    console.error('Failed to toggle GPU:', e);
                    showAlert('Failed to toggle GPU acceleration', 'error');
                });
        }
        
        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', initDashboard);
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // Page is hidden, reduce update frequency
                if (dashboardState.updateInterval) {
                    clearInterval(dashboardState.updateInterval);
                }
            } else {
                // Page is visible, resume normal updates
                startUpdateLoop();
            }
        });
    </script>
</body>
</html>